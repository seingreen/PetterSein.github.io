<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Mystic Chime Synth</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    
    <style>
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background-color: #a7d8f9;
            font-family: 'Press Start 2P', cursive;
            margin: 0;
            overflow: hidden;
        }
        #app-container {
            width: 1000px;
            height: 350px;
            background-color: #f9c5d1;
            border-radius: 15px;
            box-shadow: 0 10px 0 #e8a5b4;
            padding: 15px;
            box-sizing: border-box;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
        }
        #video-container {
            position: relative;
            width: 100%;
            height: 100%;
            background-color: #333;
            border-radius: 10px;
            overflow: hidden;
        }
        #output-canvas {
            width: 100%;
            height: 100%;
            transform: scaleX(-1);
            object-fit: contain;
            display: block;
            background-color: #333;
        }
        #video-element {
            display: none;
        }
        #startButton {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 100;
            padding: 20px 40px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            border-radius: 10px;
            border: 3px solid white;
            background: rgba(0,0,0,0.7);
            color: white;
            text-shadow: 2px 2px #000;
        }
        #startButton:hover {
            background: rgba(0,0,0,0.9);
        }
        #changeCameraButton {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 100;
            padding: 10px 15px;
            font-size: 12px;
            cursor: pointer;
            border-radius: 5px;
            border: 2px solid white;
            background: rgba(0,0,0,0.7);
            color: white;
            font-family: inherit;
        }
        #cameraList {
            position: absolute;
            top: 60px;
            left: 20px;
            z-index: 101;
            background: rgba(0,0,0,0.9);
            border-radius: 5px;
            padding: 10px;
            color: white;
            font-size: 10px;
            max-width: 300px;
        }
        .camera-option {
            padding: 5px 10px;
            cursor: pointer;
            border-radius: 3px;
            margin: 2px 0;
        }
        .camera-option:hover {
            background: rgba(255,255,255,0.2);
        }
        #status {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: white;
            background: rgba(0,0,0,0.7);
            padding: 8px 12px;
            border-radius: 5px;
            font-size: 12px;
        }
        .particle {
            position: absolute;
            width: 4px;
            height: 4px;
            background: radial-gradient(circle, rgba(255,255,255,0.9), rgba(255,255,255,0.3));
            border-radius: 50%;
            pointer-events: none;
            box-shadow: 0 0 8px rgba(255,255,255,0.8), 0 0 16px rgba(255,255,255,0.4);
            animation: lightSparkle 2s ease-out forwards;
        }
        .particle::before {
            content: '';
            position: absolute;
            top: -2px;
            left: -2px;
            right: -2px;
            bottom: -2px;
            background: radial-gradient(circle, rgba(255,255,255,0.2), transparent);
            border-radius: 50%;
            animation: shimmer 2s ease-out forwards;
        }
        @keyframes lightSparkle {
            0% {
                opacity: 1;
                transform: scale(0);
            }
            20% {
                opacity: 1;
                transform: scale(1.2);
            }
            100% {
                opacity: 0;
                transform: scale(0.3) translate(var(--dx), var(--dy));
            }
        }
        @keyframes shimmer {
            0% {
                opacity: 0;
                transform: scale(0);
            }
            50% {
                opacity: 0.6;
                transform: scale(1.5);
            }
            100% {
                opacity: 0;
                transform: scale(2);
            }
        }
    </style>
</head>
<body>
    <div id="app-container">
        <div id="video-container">
            <video id="video-element" autoplay muted playsinline></video>
            <canvas id="output-canvas"></canvas>
        </div>
        <button id="startButton">Click to Start</button>
        <button id="changeCameraButton" style="display: none;">Change Camera</button>
        <div id="status" style="display: none;"></div>
        <div id="cameraList" style="display: none;"></div>
    </div>

<script>
    const startButton = document.getElementById('startButton');
    const changeCameraButton = document.getElementById('changeCameraButton');
    const cameraListDiv = document.getElementById('cameraList');
    const canvasElement = document.getElementById('output-canvas');
    const videoElement = document.getElementById('video-element');
    const statusElement = document.getElementById('status');
    const canvasCtx = canvasElement.getContext('2d');
    
    let audioContext;
    let masterVolume;
    let reverbNode;
    let hands;
    let camera;
    let isRunning = false;
    
    const chimeNotes = {
        'C5': 523.25,
        'D5': 587.33,
        'E5': 659.25,
        'G5': 783.99,
        'A5': 880.00,
        'C6': 1046.50
    };
    const chimeScale = Object.values(chimeNotes);
    
    let lastIndexTipPosition = null;
    let canTriggerSound = true;
    let currentStream = null;
    let availableCameras = [];

    function log(message) {
        console.log(message);
        statusElement.textContent = message;
    }

    changeCameraButton.addEventListener('click', async () => {
        if (availableCameras.length === 0) {
            await loadCameraList();
        }
        toggleCameraList();
    });

    async function loadCameraList() {
        try {
            const devices = await navigator.mediaDevices.enumerateDevices();
            availableCameras = devices.filter(device => device.kind === 'videoinput');
            displayCameraList();
        } catch (error) {
            log('Failed to load camera list');
        }
    }

    function displayCameraList() {
        cameraListDiv.innerHTML = '';
        availableCameras.forEach((camera, index) => {
            const div = document.createElement('div');
            div.className = 'camera-option';
            div.textContent = camera.label || `Camera ${index + 1}`;
            div.addEventListener('click', () => selectCamera(camera.deviceId));
            cameraListDiv.appendChild(div);
        });
    }

    function toggleCameraList() {
        cameraListDiv.style.display = cameraListDiv.style.display === 'none' ? 'block' : 'none';
    }

    async function selectCamera(deviceId) {
        try {
            if (currentStream) {
                currentStream.getTracks().forEach(track => track.stop());
            }
            
            const stream = await navigator.mediaDevices.getUserMedia({
                video: {
                    deviceId: { exact: deviceId },
                    width: { ideal: 1280, min: 640 },
                    height: { ideal: 720, min: 480 }
                }
            });
            
            currentStream = stream;
            videoElement.srcObject = stream;
            cameraListDiv.style.display = 'none';
            log('Camera changed successfully');
            
        } catch (error) {
            log('Failed to switch camera');
        }
    }

    startButton.addEventListener('click', async () => {
        if (isRunning) return;
        
        startButton.textContent = 'Loading...';
        startButton.disabled = true;
        statusElement.style.display = 'block';

        try {
            log('Initializing audio system...');
            await setupAudio();
            
            log('Setting up MediaPipe...');
            await setupMediaPipe();
            
            log('Starting camera...');
            await startCamera();
            
            log('Ready! Move your hands in front of the camera.');
            setTimeout(() => {
                statusElement.style.display = 'none';
            }, 3000);
            startButton.style.display = 'none';
            changeCameraButton.style.display = 'block';
            isRunning = true;

        } catch (error) {
            log(`Error: ${error.message}`);
            startButton.textContent = 'Retry';
            startButton.disabled = false;
        }
    });

    async function setupAudio() {
        try {
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
            
            if (audioContext.state === 'suspended') {
                await audioContext.resume();
            }
            
            masterVolume = audioContext.createGain();
            masterVolume.gain.value = 0.3;
            
            reverbNode = audioContext.createConvolver();
            reverbNode.buffer = createReverbBuffer();
            
            reverbNode.connect(masterVolume);
            masterVolume.connect(audioContext.destination);
            
        } catch (error) {
            throw new Error('Audio initialization failed: ' + error.message);
        }
    }

    function createReverbBuffer() {
        const length = audioContext.sampleRate * 2;
        const buffer = audioContext.createBuffer(2, length, audioContext.sampleRate);
        
        for (let channel = 0; channel < 2; channel++) {
            const channelData = buffer.getChannelData(channel);
            for (let i = 0; i < length; i++) {
                channelData[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / length, 2);
            }
        }
        return buffer;
    }

    async function setupMediaPipe() {
        return new Promise((resolve, reject) => {
            try {
                if (typeof Hands === 'undefined') {
                    throw new Error('MediaPipe Hands library not loaded');
                }
                
                hands = new Hands({
                    locateFile: (file) => {
                        return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
                    }
                });
                
                hands.setOptions({
                    maxNumHands: 2,
                    modelComplexity: 1,
                    minDetectionConfidence: 0.7,
                    minTrackingConfidence: 0.5
                });
                
                hands.onResults(onResults);
                resolve();
                
            } catch (error) {
                reject(new Error('MediaPipe setup failed: ' + error.message));
            }
        });
    }

    async function startCamera() {
        try {
            if (typeof Camera === 'undefined') {
                await startVideoStream();
            } else {
                camera = new Camera(videoElement, {
                    onFrame: async () => {
                        await hands.send({image: videoElement});
                    },
                    width: 1280,
                    height: 720
                });
                await camera.start();
            }
            
        } catch (error) {
            throw new Error('Camera start failed: ' + error.message);
        }
    }

    async function startVideoStream() {
        try {
            // First, try to get available devices and prefer built-in camera
            const devices = await navigator.mediaDevices.enumerateDevices();
            const videoDevices = devices.filter(device => device.kind === 'videoinput');
            
            let deviceId = null;
            // Look for built-in camera (usually contains 'built-in' or 'facetime')
            const builtInCamera = videoDevices.find(device => 
                device.label.toLowerCase().includes('built-in') || 
                device.label.toLowerCase().includes('facetime') ||
                device.label.toLowerCase().includes('integrated')
            );
            
            if (builtInCamera) {
                deviceId = builtInCamera.deviceId;
            }
            
            const constraints = {
                video: { 
                    width: { ideal: 1280, min: 640 },
                    height: { ideal: 720, min: 480 },
                    aspectRatio: { ideal: 16/9 },
                    facingMode: 'user'
                }
            };
            
            // Add device constraint if we found a built-in camera
            if (deviceId) {
                constraints.video.deviceId = { ideal: deviceId };
            }
            
            const stream = await navigator.mediaDevices.getUserMedia(constraints);
            currentStream = stream;
            
            videoElement.srcObject = stream;
            
            return new Promise((resolve, reject) => {
                videoElement.addEventListener('loadedmetadata', () => {
                    canvasElement.width = videoElement.videoWidth;
                    canvasElement.height = videoElement.videoHeight;
                    log(`Camera resolution: ${videoElement.videoWidth}x${videoElement.videoHeight}`);
                    
                    processFrame();
                    resolve();
                });
                
                videoElement.addEventListener('error', reject);
                setTimeout(() => reject(new Error('Camera connection timeout')), 10000);
            });
            
        } catch (error) {
            if (error.name === 'NotAllowedError') {
                throw new Error('Camera permission denied');
            } else if (error.name === 'NotFoundError') {
                throw new Error('Camera not found');
            } else {
                throw new Error('Camera access error: ' + error.message);
            }
        }
    }

    async function processFrame() {
        if (!isRunning) return;
        
        if (videoElement.readyState >= 2) {
            await hands.send({image: videoElement});
        }
        
        requestAnimationFrame(processFrame);
    }

    function onResults(results) {
        canvasCtx.save();
        canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
        canvasCtx.drawImage(results.image, 0, 0, canvasElement.width, canvasElement.height);
        
        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
            for (const landmarks of results.multiHandLandmarks) {
                // Draw hand skeleton manually
                drawHandSkeleton(landmarks);
                drawHandLandmarks(landmarks);
                processHandGesture(landmarks);
            }
        } else {
            lastIndexTipPosition = null;
        }
        
        canvasCtx.restore();
    }

    function drawHandSkeleton(landmarks) {
        const connections = [
            [0, 1], [1, 2], [2, 3], [3, 4],
            [0, 5], [5, 6], [6, 7], [7, 8],
            [0, 9], [9, 10], [10, 11], [11, 12],
            [0, 13], [13, 14], [14, 15], [15, 16],
            [0, 17], [17, 18], [18, 19], [19, 20],
            [5, 9], [9, 13], [13, 17]
        ];

        canvasCtx.strokeStyle = 'rgba(0, 255, 255, 0.85)';
        canvasCtx.lineWidth = 1.0;
        canvasCtx.lineCap = 'round';
        canvasCtx.lineJoin = 'round';

        connections.forEach(([start, end]) => {
            const startPoint = landmarks[start];
            const endPoint = landmarks[end];
            
            if (startPoint && endPoint) {
                canvasCtx.beginPath();
                canvasCtx.moveTo(
                    startPoint.x * canvasElement.width,
                    startPoint.y * canvasElement.height
                );
                canvasCtx.lineTo(
                    endPoint.x * canvasElement.width,
                    endPoint.y * canvasElement.height
                );
                canvasCtx.stroke();
            }
        });
    }

    function drawHandLandmarks(landmarks) {
        canvasCtx.fillStyle = 'rgba(255, 255, 255, 0.9)';
        canvasCtx.strokeStyle = 'rgba(0, 255, 255, 0.6)';
        canvasCtx.lineWidth = 0.5;
        
        landmarks.forEach((landmark) => {
            const x = landmark.x * canvasElement.width;
            const y = landmark.y * canvasElement.height;
            
            canvasCtx.beginPath();
            canvasCtx.arc(x, y, 2, 0, 2 * Math.PI);
            canvasCtx.fill();
            canvasCtx.stroke();
        });
    }

    function processHandGesture(landmarks) {
        const indexTip = landmarks[8];
        if (!indexTip) return;
        
        const x = indexTip.x * canvasElement.width;
        const y = indexTip.y * canvasElement.height;
        
        canvasCtx.save();
        
        // Outer ring
        canvasCtx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
        canvasCtx.lineWidth = 1.5;
        canvasCtx.shadowColor = 'rgba(255, 255, 255, 0.4)';
        canvasCtx.shadowBlur = 8;
        
        canvasCtx.beginPath();
        canvasCtx.arc(x, y, 6, 0, 2 * Math.PI);
        canvasCtx.stroke();
        
        // Inner dot
        canvasCtx.fillStyle = 'rgba(255, 255, 255, 0.95)';
        canvasCtx.shadowBlur = 4;
        
        canvasCtx.beginPath();
        canvasCtx.arc(x, y, 2.5, 0, 2 * Math.PI);
        canvasCtx.fill();
        
        canvasCtx.restore();
        
        if (lastIndexTipPosition && canTriggerSound) {
            const velocity = Math.hypot(
                indexTip.x - lastIndexTipPosition.x,
                indexTip.y - lastIndexTipPosition.y
            );
            
            if (velocity > 0.08) {
                playChimeSound();
                createSparkleEffect(x, y);
                canTriggerSound = false;
                setTimeout(() => { canTriggerSound = true; }, 400);
            }
        }
        
        lastIndexTipPosition = { x: indexTip.x, y: indexTip.y };
    }

    function createSparkleEffect(x, y) {
        const rect = canvasElement.getBoundingClientRect();
        const absoluteX = rect.left + x;
        const absoluteY = rect.top + y;
        
        for (let i = 0; i < 6; i++) {
            const particle = document.createElement('div');
            particle.className = 'particle';
            
            const angle = (Math.PI * 2 * i) / 6 + Math.random() * 0.5;
            const distance = 15 + Math.random() * 20;
            const dx = Math.cos(angle) * distance;
            const dy = Math.sin(angle) * distance;
            
            particle.style.left = (absoluteX - 2) + 'px';
            particle.style.top = (absoluteY - 2) + 'px';
            particle.style.setProperty('--dx', dx + 'px');
            particle.style.setProperty('--dy', dy + 'px');
            particle.style.animationDelay = (i * 0.05) + 's';
            
            document.body.appendChild(particle);
            
            setTimeout(() => {
                if (particle.parentNode) {
                    particle.parentNode.removeChild(particle);
                }
            }, 2000);
        }
    }

    function playChimeSound() {
        if (!audioContext || !reverbNode) return;
        
        try {
            const currentTime = audioContext.currentTime;
            const numNotes = Math.floor(Math.random() * 4) + 3;
            
            for (let i = 0; i < numNotes; i++) {
                const frequency = chimeScale[Math.floor(Math.random() * chimeScale.length)];
                const startTime = currentTime + i * 0.12;
                
                createChimeNote(frequency, startTime);
            }
            
        } catch (error) {
            console.log('Sound playback error: ' + error.message);
        }
    }

    function createChimeNote(frequency, startTime) {
        const oscillator = audioContext.createOscillator();
        const gainNode = audioContext.createGain();
        
        const modulator = audioContext.createOscillator();
        const modGain = audioContext.createGain();
        
        modulator.frequency.value = frequency * 2.5;
        modGain.gain.value = 40;
        
        oscillator.type = 'triangle';
        oscillator.frequency.value = frequency;
        
        gainNode.gain.setValueAtTime(0, startTime);
        gainNode.gain.linearRampToValueAtTime(0.4, startTime + 0.02);
        gainNode.gain.exponentialRampToValueAtTime(0.1, startTime + 0.4);
        gainNode.gain.exponentialRampToValueAtTime(0.001, startTime + 2.0);
        
        modulator.connect(modGain);
        modGain.connect(oscillator.frequency);
        
        oscillator.connect(gainNode);
        gainNode.connect(reverbNode);
        
        oscillator.start(startTime);
        modulator.start(startTime);
        oscillator.stop(startTime + 2.0);
        modulator.stop(startTime + 2.0);
    }

    window.addEventListener('beforeunload', () => {
        if (currentStream) {
            currentStream.getTracks().forEach(track => track.stop());
        }
        if (videoElement.srcObject) {
            const stream = videoElement.srcObject;
            const tracks = stream.getTracks();
            tracks.forEach(track => track.stop());
        }
        if (audioContext) {
            audioContext.close();
        }
    });
</script>
</body>
</html>
