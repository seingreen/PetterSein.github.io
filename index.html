<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>Interactive MediaPipe Synthesizer</title>
    <script src="https://cdn.jsdelivr.net/npm/tone@14.7.77/build/Tone.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <style>
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background-color: #e0f7fa;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
        }

        .start-button {
            padding: 20px 40px;
            font-size: 24px;
            cursor: pointer;
            border: none;
            border-radius: 10px;
            background-color: #ff7043;
            color: white;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            transition: all 0.2s;
        }
        .start-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0,0,0,0.25);
        }

        #synth-container {
            width: 1000px;
            height: 350px;
            background: #a5d6a7; /* Light green background */
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            display: none; /* Initially hidden */
            flex-direction: column;
            overflow: hidden;
            position: relative;
        }

        #main-content {
            display: flex;
            height: 250px; /* Height for modules and video */
        }

        #video-wrapper {
            position: relative;
            width: 333px; /* 1/3 of the width */
            height: 250px;
            background-color: #333;
        }

        #webcam, #output-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            transform: scaleX(-1); /* Mirror view */
            object-fit: cover;
        }
        
        #hat-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none; /* Allow clicks to pass through */
            transform: scaleX(-1); /* Match canvas mirroring */
        }

        #hat-image {
            position: absolute;
            width: 100px; /* Default size, will be adjusted by JS */
            transform-origin: center bottom;
            transition: transform 0.1s linear, opacity 0.1s linear;
        }

        #module-wrapper {
            display: flex;
            flex-grow: 1;
            padding: 10px;
            gap: 10px;
        }

        .module {
            flex: 1;
            border-radius: 8px;
            padding: 10px;
            color: #333;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        .module h3 {
            margin: 0 0 15px 0;
            font-size: 14px;
            font-weight: bold;
            text-align: center;
            width: 100%;
            border-bottom: 1px solid rgba(0,0,0,0.2);
            padding-bottom: 5px;
        }

        .knob {
            width: 50px;
            height: 50px;
            background-color: #f0f0f0;
            border: 2px solid #ccc;
            border-radius: 50%;
            position: relative;
            margin-bottom: 10px;
        }

        .knob-indicator {
            width: 4px;
            height: 23px;
            background-color: #333;
            position: absolute;
            top: 2px;
            left: 23px;
            transform-origin: bottom center;
            border-radius: 2px;
            transition: transform 0.1s linear;
        }

        .knob-label {
            font-size: 12px;
        }

        .module.ambient { background-color: #81d4fa; } /* Light Blue */
        .module.effects { background-color: #ce93d8; } /* Light Purple */
        .module.output { background-color: #ef9a9a; } /* Light Red */

        #keyboard-wrapper {
            display: flex;
            width: 100%;
            height: 100px; /* Height for keyboard */
            background: #424242;
            position: relative;
        }
        .key {
            border: 1px solid #333;
            box-sizing: border-box;
            transition: background-color 0.1s;
        }
        .key.white {
            height: 100%;
            width: calc(100% / 8); /* 8 white keys */
            background-color: white;
            z-index: 1;
        }
        .key.black {
            position: absolute;
            height: 60%;
            width: calc(100% / 14);
            background-color: #212121;
            z-index: 2;
            border-color: #111;
        }
        .key.active {
            background-color: #64b5f6; /* Highlight color */
        }
        
        /* Positioning black keys */
        .key.black[data-key="C#4"] { left: 9.375%; }
        .key.black[data-key="D#4"] { left: 21.875%; }
        .key.black[data-key="F#4"] { left: 46.875%; }
        .key.black[data-key="G#4"] { left: 59.375%; }
        .key.black[data-key="A#4"] { left: 71.875%; }

        #hat-controls {
            position: absolute;
            top: 10px;
            right: 10px;
            display: flex;
            flex-direction: column;
            gap: 5px;
            z-index: 100;
        }
        #hat-controls button {
            background: rgba(255,255,255,0.7);
            border: 1px solid rgba(0,0,0,0.2);
            border-radius: 5px;
            cursor: pointer;
            padding: 5px;
        }

    </style>
</head>
<body>

    <button id="start-button" class="start-button">Start Synthesis</button>

    <div id="synth-container">
        <!-- Hat Controls -->
        <div id="hat-controls">
            <button onclick="selectHat('none')">No Hat</button>
            <button onclick="selectHat('hat1.png')">ðŸ§¢</button>
            <button onclick="selectHat('hat2.png')">ðŸ‘‘</button>
        </div>
        
        <div id="main-content">
            <div id="video-wrapper">
                <video id="webcam" playsinline style="display: none;"></video>
                <canvas id="output-canvas"></canvas>
                <div id="hat-container">
                    <img id="hat-image" src="" style="display: none;" alt="User Hat"/>
                </div>
            </div>

            <div id="module-wrapper">
                <div class="module ambient">
                    <h3>AMBIENT</h3>
                    <div class="knob">
                        <div id="mouth-knob-indicator" class="knob-indicator"></div>
                    </div>
                    <span class="knob-label">MOUTH OPEN</span>
                </div>
                <div class="module effects">
                    <h3>EFFECTS</h3>
                     <div class="knob">
                        <div id="reverb-knob-indicator" class="knob-indicator"></div>
                    </div>
                    <span class="knob-label">REVERB</span>
                </div>
                 <div class="module output">
                    <h3>KEYBOARD</h3>
                     <div class="knob">
                        <div id="vol-knob-indicator" class="knob-indicator"></div>
                    </div>
                    <span class="knob-label">VOLUME</span>
                </div>
            </div>
        </div>
        
        <div id="keyboard-wrapper">
            <!-- White Keys -->
            <div class="key white" data-key="C4"></div>
            <div class="key white" data-key="D4"></div>
            <div class="key white" data-key="E4"></div>
            <div class="key white" data-key="F4"></div>
            <div class="key white" data-key="G4"></div>
            <div class="key white" data-key="A4"></div>
            <div class="key white" data-key="B4"></div>
            <div class="key white" data-key="C5"></div>
            <!-- Black Keys -->
            <div class="key black" data-key="C#4"></div>
            <div class="key black" data-key="D#4"></div>
            <div class="key black" data-key="F#4"></div>
            <div class="key black" data-key="G#4"></div>
            <div class="key black" data-key="A#4"></div>
        </div>
    </div>

<script>
    // --- DOM Elements ---
    const startButton = document.getElementById('start-button');
    const synthContainer = document.getElementById('synth-container');
    const videoElement = document.getElementById('webcam');
    const canvasElement = document.getElementById('output-canvas');
    const canvasCtx = canvasElement.getContext('2d');
    const hatImage = document.getElementById('hat-image');
    const mouthKnob = document.getElementById('mouth-knob-indicator');
    const reverbKnob = document.getElementById('reverb-knob-indicator');
    const volKnob = document.getElementById('vol-knob-indicator');

    // --- MediaPipe Instances ---
    let faceMesh;
    let hands;
    let camera;

    // --- Audio (Tone.js) ---
    let isAudioReady = false;
    let ambientSynth, keyboardSynth, reverb;

    // --- State Variables ---
    let mouthOpenness = 0; // 0.0 to 1.0
    let keyStates = {}; // Tracks which keys are currently "pressed" by fingers
    
    // --- Keyboard Definition ---
    const keyElements = document.querySelectorAll('.key');
    let keyData = [];

    // --- Main Setup Function ---
    function initialize() {
        setupMediaPipe();
        setupAudio();
        setupKeyboard();
        
        camera = new Camera(videoElement, {
            onFrame: async () => {
                await faceMesh.send({ image: videoElement });
                await hands.send({ image: videoElement });
            },
            width: 640,
            height: 480
        });
        camera.start();

        // Show synth and hide button
        synthContainer.style.display = 'flex';
        startButton.style.display = 'none';
        
        // Start main loop
        requestAnimationFrame(updateLoop);
    }

    function setupMediaPipe() {
        faceMesh = new FaceMesh({
            locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`
        });
        faceMesh.setOptions({
            maxNumFaces: 1,
            refineLandmarks: true,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });
        faceMesh.onResults(onFaceResults);

        hands = new Hands({
            locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
        });
        hands.setOptions({
            maxNumHands: 2,
            modelComplexity: 1,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });
        hands.onResults(onHandResults);
    }

    async function setupAudio() {
        await Tone.start();
        console.log("Audio context started.");

        // Master Reverb
        reverb = new Tone.Reverb({
            decay: 1.5,
            wet: 0.3
        }).toDestination();

        // 1. Ambient Synth (controlled by mouth)
        // A soft, evolving pad sound
        ambientSynth = new Tone.NoiseSynth({
            noise: { type: 'pink' },
            envelope: { attack: 0.5, decay: 0.1, sustain: 1.0, release: 0.8 },
            volume: -25 // Start quiet
        }).connect(reverb);
        
        // AutoFilter gives it a nice sweeping motion
        const autoFilter = new Tone.AutoFilter("4n").start();
        ambientSynth.connect(autoFilter);
        autoFilter.connect(reverb);
        
        ambientSynth.triggerAttack();

        // 2. Keyboard Synth (controlled by hands)
        keyboardSynth = new Tone.PolySynth(Tone.Synth, {
            oscillator: { type: 'fmsine' },
            envelope: { attack: 0.05, decay: 0.2, sustain: 0.6, release: 0.5 },
            volume: -10
        }).connect(reverb);

        isAudioReady = true;
    }

    function setupKeyboard() {
        const keyboardWrapper = document.getElementById('keyboard-wrapper');
        const wrapperRect = keyboardWrapper.getBoundingClientRect();

        keyElements.forEach(keyEl => {
            const keyRect = keyEl.getBoundingClientRect();
            const note = keyEl.dataset.key;
            keyData.push({
                element: keyEl,
                note: note,
                rect: {
                    left: (keyRect.left - wrapperRect.left) / wrapperRect.width,
                    right: (keyRect.right - wrapperRect.left) / wrapperRect.width,
                    top: 0,
                    bottom: 1
                }
            });
            keyStates[note] = false;
        });
    }

    // --- MediaPipe Result Handlers ---
    function onFaceResults(results) {
        // Store face landmarks if found, they will be used in the main updateLoop
        window.faceLandmarks = results.multiFaceLandmarks.length > 0 ? results.multiFaceLandmarks[0] : null;
    }

    function onHandResults(results) {
        // Store hand landmarks
        window.handLandmarks = results.multiHandLandmarks;
    }

    // --- Main Update Loop (ran by requestAnimationFrame) ---
    function updateLoop() {
        canvasCtx.save();
        canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
        
        // Match video aspect ratio inside canvas
        const videoRatio = videoElement.videoWidth / videoElement.videoHeight;
        const canvasRatio = canvasElement.width / canvasElement.height;
        let drawWidth, drawHeight, drawX, drawY;

        if (videoRatio > canvasRatio) {
            drawHeight = canvasElement.height;
            drawWidth = drawHeight * videoRatio;
            drawX = (canvasElement.width - drawWidth) / 2;
            drawY = 0;
        } else {
            drawWidth = canvasElement.width;
            drawHeight = drawWidth / videoRatio;
            drawX = 0;
            drawY = (canvasElement.height - drawHeight) / 2;
        }
        canvasCtx.drawImage(videoElement, drawX, drawY, drawWidth, drawHeight);

        // Process Face Data
        if (window.faceLandmarks) {
            const landmarks = window.faceLandmarks;
            processMouth(landmarks);
            positionHat(landmarks);
        }

        // Process Hand Data
        if (window.handLandmarks) {
            processHands(window.handLandmarks);
        }

        // Update Audio & Visuals based on state
        if (isAudioReady) {
            updateAudio();
            updateVisuals();
        }

        canvasCtx.restore();
        requestAnimationFrame(updateLoop);
    }
    
    function processMouth(landmarks) {
        // Landmarks for upper and lower lip
        const upperLip = landmarks[13];
        const lowerLip = landmarks[14];
        // Landmarks for face size reference (cheek to cheek)
        const leftCheek = landmarks[234];
        const rightCheek = landmarks[454];

        const mouthDist = Math.hypot(upperLip.x - lowerLip.x, upperLip.y - lowerLip.y);
        const faceWidth = Math.hypot(leftCheek.x - rightCheek.x, leftCheek.y - rightCheek.y);
        
        // Normalize mouth opening based on face width for consistency
        mouthOpenness = Math.min(1.0, Math.max(0.0, (mouthDist / faceWidth - 0.05) * 5));
    }
    
    function positionHat(landmarks) {
        if (!hatImage.src || hatImage.style.display === 'none') return;
        
        const forehead = landmarks[10];
        const leftTemple = landmarks[227];
        const rightTemple = landmarks[447];

        if (forehead && leftTemple && rightTemple) {
            const headWidth = Math.hypot(leftTemple.x - rightTemple.x, leftTemple.y - rightTemple.y) * canvasElement.width;
            
            // Calculate angle of the head
            const angle = Math.atan2(rightTemple.y - leftTemple.y, rightTemple.x - leftTemple.x);

            hatImage.style.width = `${headWidth * 1.4}px`; // Hat is slightly wider than temples
            hatImage.style.left = `${forehead.x * canvasElement.width}px`;
            hatImage.style.top = `${forehead.y * canvasElement.height}px`;
            hatImage.style.transform = `translate(-50%, -100%) rotate(${angle}rad)`;
        }
    }

    function processHands(landmarks) {
        const fingertips = [];
        // Landmarks for fingertips: 4=Thumb, 8=Index, 12=Middle, 16=Ring, 20=Pinky
        const tipIds = [4, 8, 12, 16, 20];

        for (const hand of landmarks) {
            tipIds.forEach(id => {
                const tip = hand[id];
                fingertips.push({ x: tip.x, y: tip.y });
            });
        }
        
        const pressedNotes = new Set();

        for (const finger of fingertips) {
            // Invert x because the canvas is mirrored
            const normalizedX = finger.x;
            const normalizedY = finger.y;

            // Check if finger is within the keyboard's vertical area
            if (normalizedY > 250 / 350) { // Keyboard starts at 250px out of 350px
                for (const key of keyData) {
                    if (normalizedX > key.rect.left && normalizedX < key.rect.right) {
                        pressedNotes.add(key.note);
                        break; // One finger can only press one key
                    }
                }
            }
        }

        // Compare with previous state to trigger notes
        for (const key of keyData) {
            const isPressed = pressedNotes.has(key.note);
            if (isPressed && !keyStates[key.note]) {
                // Key press
                keyboardSynth.triggerAttack(key.note);
                keyStates[key.note] = true;
                key.element.classList.add('active');
            } else if (!isPressed && keyStates[key.note]) {
                // Key release
                keyboardSynth.triggerRelease(key.note);
                keyStates[key.note] = false;
                key.element.classList.remove('active');
            }
        }
    }

    function updateAudio() {
        // Map mouthOpenness (0-1) to ambient synth volume
        // Use a curve to make it more expressive
        const volumeDb = Tone.gainToDb(mouthOpenness * mouthOpenness); // squared for faster ramp up
        ambientSynth.volume.rampTo(volumeDb > -60 ? volumeDb : -Infinity, 0.1);
        
        // Map mouthOpenness to reverb wetness
        reverb.wet.rampTo(0.2 + mouthOpenness * 0.5, 0.1);
    }
    
    function updateVisuals() {
        // Knobs rotate from -135 to +135 degrees (270 total)
        const rotation = -135 + (mouthOpenness * 270);
        mouthKnob.style.transform = `rotate(${rotation}deg)`;
        
        const reverbRotation = -135 + ((reverb.wet.value / 0.7) * 270);
        reverbKnob.style.transform = `rotate(${reverbRotation}deg)`;
        
        // A dummy volume knob for show
        volKnob.style.transform = `rotate(45deg)`;
    }
    
    // --- UI Control Functions ---
    window.selectHat = function(hatFile) {
        if (hatFile === 'none') {
            hatImage.style.display = 'none';
        } else {
            hatImage.src = hatFile;
            hatImage.style.display = 'block';
        }
    }
    
    startButton.addEventListener('click', initialize);

</script>
</body>
</html>
